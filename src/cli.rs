use clap::{Args, Parser, Subcommand};

/// Dedupe & Compile Yara Rules
#[derive(Parser)]
#[clap(name = "Yara Dedupe")]
#[command(version, about)]
pub struct CliOpts {
    #[clap(subcommand)]
    pub cmd: SubCommand,
}

#[derive(Subcommand)]
pub enum SubCommand {
    /// Remove duplicates from a vector of YARA rules.
    ///
    /// This function takes a vector of YARA rules and removes any duplicates. The resulting vector
    /// will contain only unique rules.
    ///
    /// # Arguments
    ///
    /// * `rules` - A vector of YARA rules.
    ///
    /// # Example
    ///
    /// ```norun
    /// use yara_dedupe::dedupe;
    ///
    /// let rules = vec![
    ///     "rule1",
    ///     "rule2",
    ///     "rule1",
    /// ];
    ///
    /// let deduplicated_rules = dedupe(rules);
    ///
    /// assert_eq!(deduplicated_rules, vec![
    ///     "rule1",
    ///     "rule2",
    /// ]);
    /// ```
    Dedupe(Dedupe),
    /// Compile a YARA rule into a binary format.
    ///
    /// This function takes a YARA rule as input and compiles it into a binary format that can be loaded
    /// and used by the YARA engine for matching. The resulting binary format can then be saved to file
    /// or used directly in memory for matching against data.
    ///
    /// # Arguments
    ///
    /// * `rule` - A YARA rule in string format.
    ///
    /// # Returns
    ///
    /// A `Result<Vec<u8>, String>` representing the compilation result. If the compilation is successful,
    /// the `Result` will contain a vector of bytes representing the compiled binary format. If the compilation
    /// fails, the `Result` will contain an error message as a `String`.
    ///
    /// # Example
    ///
    /// ```norun
    /// use yara_compiler::compile;
    ///
    /// let rule = r#"
    ///     rule example_rule {
    ///         strings:
    ///             $string1 = "example"
    ///         condition:
    ///             $string1
    ///     }
    /// "#;
    ///
    /// let compiled_rule = compile(rule);
    ///
    /// match compiled_rule {
    ///     Ok(bytes) => {
    ///         // Save binary format to file
    ///         std::fs::write("compiled_rule.bin", bytes).expect("Failed to write file");
    ///         println!("Rule compiled successfully!");
    ///     },
    ///     Err(error) => {
    ///         println!("Failed to compile rule: {}", error);
    ///     }
    /// }
    /// ```
    Compile(Compile),
}

/// A subcommand for deduping yara rules
#[derive(Args)]
pub struct Dedupe {
    /// The input directory/ies for the deduplication process.
    ///
    /// This argument specifies the input directory/ies from which the program will search for duplicate files.
    /// It is a required argument and accepts one or more directory paths.
    ///
    /// # Notes
    ///
    /// - Multiple directories can be passed as separate arguments.
    /// - Each directory path should be valid and point to an existing directory.
    /// - The program will recursively search all the directories specified for duplicate files.
    /// - If a directory contains subdirectories, the program will also search for duplicate files within the subdirectories.
    /// - The program will throw an error if no valid directory paths are provided.
    /// - The program will throw an error if any of the specified directories do not exist.
    #[clap(short = 'i', long = "input-dir", required = true, use_value_delimiter = true, num_args = 1..)]
    pub input_dir: Vec<String>,

    /// The output file for the deduplication results.
    ///
    /// This file will contain the deduplication results generated by the program.
    /// It is a required argument and specifies the location where the output file will be created.
    /// # Notes
    ///
    /// - The file must have a valid name and extension.
    /// - If the file already exists, it will be overwritten.
    /// - The program will throw an error if the specified location or file name is invalid.
    /// - The necessary write permissions should be available for the specified location.
    #[clap(short = 'o', long = "output-file", required = true)]
    pub output_file: String,

    /// Whether to skip certain rules when running the program.
    ///
    /// By specifying this flag, you can skip the execution of certain rules without modifying the code.
    /// This can be useful if you want to exclude specific rules from the execution for testing or debugging purposes.
    ///
    /// # Notes
    ///
    /// - If this flag is not specified, all rules will be executed.
    /// - If you want to skip multiple rules, you can provide a comma-separated list of rule names.
    /// - The rule names should match the names specified in the yara rule files.
    /// - If a rule name is misspelled or does not exist, it will be ignored and the rest of the rules will still be executed.
    ///
    /// # Example
    ///
    /// ```
    /// // Skip executing the "rule1" and "rule2"
    /// // $ ./program --skip-rules rule1,rule2
    /// ```
    ///
    /// It is an optional argument and can be used to specify the rules to skip during execution.
    ///
    #[clap(long = "skip-rules")]
    pub skip_rules: Option<String>,
}

/// A subcommand for compiling yara rules
#[derive(Args)]
pub struct Compile {
    /// The path to the input file that will be processed.
    /// the input file path must be provided when running the application.
    #[clap(required = true)]
    pub input_file: String,
}

impl CliOpts {
    /// Parse command line arguments and return an instance of `Self`.
    ///
    /// # Example
    ///
    /// ```rust,norun
    ///
    /// let parsed_args = Cli::parse_cli();
    /// ```
    ///
    /// # Returns
    ///
    /// An instance of `Self` with the command line arguments parsed.
    pub fn parse_cli() -> Self {
        Self::parse()
    }
}
